{
	"papers" : [
		{
			"id" : 1,
			"title" : "Extracting Parallel Control Flow Graphs with Synchronization Information from Java Program",
			"abs"   : "Developers spend a significant amount of their time on understanding programs, especially if these programs are large and use multi-threading. Regarding such programs, one key aspect concerns the understanding of how shared data is accessed by the different threads, for instance to prevent race conditions. Most of the existing approaches address this issue by using dynamic analysis of execution traces. However, dynamic analysis has two main shortcomings: first, the program needs to be executable, and, second, execution traces typically do not cover all possible scenarios. In this paper, we propose an approach that uses static analysis to extract Parallel Control Flow Graphs with Synchronization Information (PCFGs-SI) from source code. While CFGs help to understand the control flow of source code statements executed in parallel, synchronization edges highlight the shared access to critical code blocks protected by a locking mechanism. We evaluated our approach and heuristics with five open source Java projects that use two specific locking mechanisms to handle the communication between different threads, namely synchronized code blocks and synchronized methods. The results show that our approach extracts synchronization edges between synchronized code blocks with a precision of 97.50% and recall of 99.50%. Edges between calls to synchronized methods are extracted with a precision of 100% and recall of 96.35%. We demonstrate the usefulness of our approach with two examples, in which our approach is used to detect shortcomings in the use of locking in Java.",
			"authors" : "G. Liva, F. Spegni, L. Spalazzi, A. Bollin, M. Pinzger",
			"url"  : "../papers/AAU-SERG-2017-001.pdf",
			"tool" : "https://git-isys.aau.at/giliva/java-time-verification/tree/master",
			"year" : "2017",
			"venue": "Tecnical Report",
			"img"  : "pcfgsi.png",
			"img_caption" : "Excerpt of the PCFGs-SI extracted from the Jetty project showing three mustbe-synchronized method edges between the two doStop methods of the classes ClientContainer and WebSocketClient. Nodes labeled with \"...\" represent groups of statements not relevant for the example.",
			"pages": "10",
			"ENTRY_ID" : "liva2017pcfg",
			"date" : "1451606400"
		},
		{
			"id" : 2,
			"title" : "Extracting Timed Automata from Java Methods",
			"abs"   : "The verification of the time behavior in distributed, multi-threaded programs is challenging, mainly because modern programming languages only provide means to represent time without a proper semantics. Current approaches to extract time models from source code represent time only as a sequence of events or require developers to manually provide a formal model of the time behavior. This makes it difficult for developers to verify various aspects of their systems, such as timeouts, delays and periodicity of the execution. In this paper, we introduce a definition of the time semantics of the Java programming language. Based on the semantics, we present an approach to automatically extract timed automata and their time constraints from the Java methods source code. First, we detect Java statements which involve time, from which we then extract the timed automata that are directly amenable to the verification of time properties of the methods. We evaluated the accuracy of our approach on ten open source Java projects that heavily use time in their source code. The results show a precision of 98.62% and recall of 95.37% in extracting time constraints from Java code. Finally, we demonstrate the effectiveness of our approach with five reported bugs of four different Apache systems that we could confirm.",
			"authors" : "G. Liva, M. T. Khan, M. Pinzger",
			"url"  : "../papers/Extracting_Timed_Automata_from_Java_Methods.pdf",
			"tool" : "https://github.com/rtse-project/extracting-timed-automata",
			"year" : "2017",
			"venue": "Proceedings of the IEEE 17th International Working Conference on Source Code Analysis and Manipulation (SCAM)",
			"img"  : "timedautomata.png",
			"img_caption" : "The graph on the left depicts the timed automaton extracted from the source code presented in Listing 1. State names represent the source code line numbers. The graph on the right depicts the same automaton with concrete values inferred from executing the program.",
			"pages": "91--100",
			"ENTRY_ID" : "liva2017extracting",
			"date" : "1501545600"
		},
		{
			"id" : 3,
			"title" : "Modeling Time in Java Programs for Automatic Error Detection",
			"abs"   : "Modern programming languages, such as Java, represent time as integer variables, called timestamps. Timestamps allow developers to tacitly model incorrect time values resulting in a program failure because any negative value or every positive value is not necessarily a valid time representation. Current approaches to automatically detect errors in programs, such as Randoop and FindBugs, cannot detect such errors because they treat timestamps as normal integer variables and test them with random values verifying if the program throws an exception. In this paper, we present an approach that considers the time semantics of the Java language to systematically detect time related errors in Java programs. With the formal time semantics, our approach determines which integer variables handle time and which statements use or alter their values. Based on this information, it translates these statements into an SMT model that is passed to an SMT solver. The solver formally verifies the correctness of the model and reports the violations of time properties in that program. For the evaluation, we have implemented our approach in a prototype tool and applied it to the source code of 20 Java open source projects. The results show that our approach is scalable and it is capable of detecting time errors precisely enough allowing its usability in real-world applications.",
			"authors" : "G. Liva, M. T. Khan, F. Spegni, L. Spalazzi, A. Bollin, M. Pinzger",
			"url"  : "../papers/Modeling_Time_in_Java_Programs_for_Automatic_Error_Detection.pdf",
			"tool" : "https://github.com/rtse-project/automatic-error-detection",
			"year" : "2018",
			"venue": "Proceedings of the 6th Conference on Formal Methods in Software Engineering (FormaliSE)",
			"img"  : "approach.png",
			"img_caption" : "Overview of our approach for detecting time property violations. Time Slice slices the program keeping only the statements that alter and use time variables. Path Generation generates multiple execution paths of the slice based on its control flow. SMT Translation translates each path into SMT constraints. Each model of SMT constraints is fed into an SMT solver to check for violations of time properties in the source code.",
			"pages": "50--59",
			"ENTRY_ID" : "liva2018modelling",
			"date" : "1535760000"
		},
		{
			"id" : 4,
			"title" : "Automatic verification of time behavior of programs",
			"abs"   : "Automatic verification of software could save companies from huge losses due to errors in their programs. Existing techniques to prevent and detect errors are mainly based on imprecise heuristics which can report false positives. Formal verification techniques are an alternative to the heuristic approaches. They are more precise and can report errors with higher rigor. However, they cannot be directly applied because current programming languages have no defined semantics that specifies how the source code is interpreted in the execution of programs. Moreover, no existing work tries to develop a semantics for the time domain. The target of this thesis is to provide a verification framework based on a defined time semantics that can help developers to automatically detect time related errors in the behavior of programs. We define a time semantics that allows us to ascribe a meaning to source code statements that alter and use time. Based on the time semantics, we develop an approach to (i) automatically assert time properties and (ii) reverse engineer timed automata, a formal model of the time behavior that is amenable for verification. We plan to evaluate our approaches with quantitative and qualitative studies. The quantitative studies will measure the performance of our approaches in open source projects and the qualitative studies will collect the developers' feedback about the applicability and usefulness of our proposed techniques.",
			"authors" : "G. Liva",
			"url"  : "../papers/expose.pdf",
			"tool" : "",
			"year" : "2018",
			"venue": "Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings (ICSE)",
			"img"  : "schedule.png",
			"img_caption" : "Schedule of the work for the PhD proposal",
			"pages": "468--471",
			"ENTRY_ID" : "liva2018automatic",
			"date" : "1535660000"
		},
		{
			"id" : 5,
			"title" : "Towards Model Checking Security of Real Time Java Software",
			"abs"   : "More and more software libraries and applications in high-performance computing and distributed systems are coded using the Java programming language. The correctness of such pieces of code w.r.t. a given set of security policies often depends on the correct handling of timing between concurrent or recurrent events. Model-checking has proven to be an effective tool for verifying correctness of software. In spite of the growing importance of this application area of formal methods, though, no one targets the problem of verifying the correctness of real-time software w.r.t. timed specifications. The few existing works focus on very different problems, such as schedulability analysis of Java tasks. We describe an approach combining rule-based static analysis together with symbolic execution of Java code to extract networks of timed automata from existing software and then use Uppaal to model-check it against timed specifications. We claim that this approach can be helpful in model-checking security policies of real time java software.",
			"authors" : "F. Spegni, L. Spalazzi, L. Giovanni, M. Pinzger",
			"url"  : "../papers/SHPCS_2018_paper_5.pdf",
			"tool" : "https://git-isys.aau.at/giliva/java-time-verification/tree/term_rewriting",
			"year" : "2018",
			"venue": "Proceedings of the 13th International Workshop on Security and High Performance Computing Systems (SHPCS 2018)",
			"img"  : "model.png",
			"img_caption" : "A methodology for extracting networks of timed automata from Java code.",
			"pages": "to-appear",
			"ENTRY_ID" : "spegni2018towards",
			"date" : "1536660000"
		},
		{
			"id" : 6,
			"title" : "Semantics-driven extraction of timed automata from Java programs",
			"abs"   : "The automatic verification of time properties of models extracted from programs is challenging, mainly because modern programming languages, such as Java, represent time without a proper semantics. Current approaches to extract time models from source code either represent time only as a tree-like sequence of events or require developers to manually provide a formal model of the time behavior. This makes it difficult for software developers to verify various aspects of their systems, such as timeouts, delays and periodicity of the execution. In this paper, we introduce a formal definition of the time semantics for the Java programming language. Based on the semantics, we present an approach to automatically extract timed automata and their time constraints from Java programs at method level. First, our approach detects the Java statements that involve time, from which it then extracts the timed automata. Our extracted automata are directly amenable to the verification of time properties of the corresponding Java methods. We evaluated the accuracy of our approach on twenty open source Java projects that implement time behavior in their source code. The results show that our approach achieves 100% precision and recall in identifying time related information. They also show that 95% of the timed automata extracted from source code correctly model the time behavior of the method. Finally, we show the applicability of our timed automata to identify eight real errors in four open source Apache systems.",
			"authors" : "L. Giovanni, K. Muhammad Taimoor, M. Pinzger",
			"url"  : "../papers/emse_preprint.pdf",
			"tool" : "https://git-isys.aau.at/giliva/java-time-verification/",
			"year" : "2019",
			"venue": "Empirical Software Engineering Journal",
			"img"  : "approachEMSE.png",
			"img_caption" : "Overview of our approach to extract a timed automaton of a Java method.",
			"pages": "1--37",
			"ENTRY_ID" : "liva2019semantics",
			"date" : "1536670000"
		},
		{
			"id" : 7,
			"title" : "Automatic Repair of Timestamp Comparisons",
			"abs"   : "Automated program repair has the potential to reduce the developers’ effort to ﬁx errors in their code. In particular, modern programming languages, such as Java, C, and C#, represent time as integer variables that suffer from integer overﬂow, introducing subtle errors that are hard to discover and repair. Recent researches on automated program repair rely on test cases to discover failures to correct, making them suitable only for regression errors. We propose a new strategy to automatically repair programs that suffer from timestamp overﬂows that are manifested in comparison expressions. It uniﬁes the beneﬁts of static analysis and automatic program repair avoiding dependency on testing to identify and correct defected code. Our approach performs an abstract analysis over the time domain of a program using a Time Type System to identify the problematic comparison expressions. The repairing strategy rewrites the timestamp comparisons exploiting the binary representation of machine numbers to correct the code. We have validated the applicability of our approach with 20 open source Java projects. The results show that it is able to correctly repair all 246 identiﬁed errors. To further validate the reliability of our approach, we have proved the soundness of both, type system and repairing strategy. Furthermore, several patches for three open source projects have been acknowledged and accepted by their developers.",
			"authors" : "L. Giovanni, K. Muhammad Taimoor, M. Pinzger, F. Spegni, L. Spalazzi",
			"url"  : "../papers/TSE.pdf",
			"tool" : "https://github.com/rtse-project/automatic-repair-time-comparison/",
			"year" : "2019",
			"venue": "IEEE Transactions on Software Engineering",
			"img"  : "approachTSE.png",
			"img_caption" : "Overview of our approach to repair timestamp comparisons.",
			"pages": "1--13",
			"ENTRY_ID" : "liva2019automatic",
			"date" : "1571616000"
		}
		,
		{
			"id" : 8,
			"title" : "Verifying temporal specifications of Java programs",
			"abs"   : "Many Java programs encode temporal behaviors in their source code, typically mixing three features provided by the Java language: (1) pausing the execution for a limited amount of time, (2) waiting for an event that has to occur before a deadline expires, and (3) comparing timestamps. In this work, we show how to exploit modern SMT solvers together with static analysis in order to produce a network of timed automata approximating the temporal behavior of a set of Java threads. We also prove that the presented abstraction preserves the truth of MTL and ATCTL formulae, two well-known logics for expressing timed specifications. As far as we know, this is the first feasible approach enabling the user to automatically model check timed specifications of Java software directly from the source code.",
			"authors" : "F. Spegni, L. Spalazzi, L. Giovanni, M. Pinzger, A. Bollin",
			"url"  : "https://link.springer.com/content/pdf/10.1007/s11219-019-09488-9.pdf",
			"tool" : "",
			"year" : "2020",
			"venue": "Springer Software Quality Journal",
			"img"  : "paper8.png",
			"img_caption" : "An example of state space extraction: a its very simple source code, b the related concrete state space, the abstract state space based c on a predicate abstraction, and d on the control flow abstraction.",
			"pages": "vol. 28, 695--744",
			"ENTRY_ID" : "spegni2020verifying",
			"date" : "1590408000"
		}
	]
}
