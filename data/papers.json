{
	"papers" : [
		{
			"id" : 1,
			"title" : "Extracting Parallel Control Flow Graphs with Synchronization Information from Java Program",
			"abs"   : "Developers spend a significant amount of their time on understanding programs, especially if these programs are large and use multi-threading. Regarding such programs, one key aspect concerns the understanding of how shared data is accessed by the different threads, for instance to prevent race conditions. Most of the existing approaches address this issue by using dynamic analysis of execution traces. However, dynamic analysis has two main shortcomings: first, the program needs to be executable, and, second, execution traces typically do not cover all possible scenarios. In this paper, we propose an approach that uses static analysis to extract Parallel Control Flow Graphs with Synchronization Information (PCFGs-SI) from source code. While CFGs help to understand the control flow of source code statements executed in parallel, synchronization edges highlight the shared access to critical code blocks protected by a locking mechanism. We evaluated our approach and heuristics with five open source Java projects that use two specific locking mechanisms to handle the communication between different threads, namely synchronized code blocks and synchronized methods. The results show that our approach extracts synchronization edges between synchronized code blocks with a precision of 97.50% and recall of 99.50%. Edges between calls to synchronized methods are extracted with a precision of 100% and recall of 96.35%. We demonstrate the usefulness of our approach with two examples, in which our approach is used to detect shortcomings in the use of locking in Java.",
			"authors" : "G. Liva, F. Spegni, L. Spalazzi, A. Bollin, M. Pinzger",
			"url"  : "./papers/AAU-SERG-2017-001.pdf",
			"tool" : "https://git-isys.aau.at/giliva/java-time-verification/tree/master",
			"year" : "2017",
			"venue": "Tecnical Report",
			"img"  : "pcfgsi.png",
			"img_caption" : "Excerpt of the PCFGs-SI extracted from the Jetty project showing three mustbe-synchronized method edges between the two doStop methods of the classes ClientContainer and WebSocketClient. Nodes labeled with \"...\" represent groups of statements not relevant for the example.",
			"pages": "10",
			"ENTRY_ID" : "liva2017pcfg",
			"date" : "1451606400"
		},
		{
			"id" : 2,
			"title" : "Extracting Timed Automata from Java Methods",
			"abs"   : "The verification of the time behavior in distributed, multi-threaded programs is challenging, mainly because modern programming languages only provide means to represent time without a proper semantics. Current approaches to extract time models from source code represent time only as a sequence of events or require developers to manually provide a formal model of the time behavior. This makes it difficult for developers to verify various aspects of their systems, such as timeouts, delays and periodicity of the execution. In this paper, we introduce a definition of the time semantics of the Java programming language. Based on the semantics, we present an approach to automatically extract timed automata and their time constraints from the Java methods source code. First, we detect Java statements which involve time, from which we then extract the timed automata that are directly amenable to the verification of time properties of the methods. We evaluated the accuracy of our approach on ten open source Java projects that heavily use time in their source code. The results show a precision of 98.62% and recall of 95.37% in extracting time constraints from Java code. Finally, we demonstrate the effectiveness of our approach with five reported bugs of four different Apache systems that we could confirm.",
			"authors" : "G. Liva, M. T. Khan, M. Pinzger",
			"url"  : "./papers/Extracting_Timed_Automata_from_Java_Methods.pdf",
			"tool" : "https://github.com/rtse-project/extracting-timed-automata",
			"year" : "2017",
			"venue": "Proceedings of the IEEE 17th International Working Conference on Source Code Analysis and Manipulation (SCAM)",
			"img"  : "timedautomata.png",
			"img_caption" : "The graph on the left depicts the timed automaton extracted from the source code presented in Listing 1. State names represent the source code line numbers. The graph on the right depicts the same automaton with concrete values inferred from executing the program.",
			"pages": "91--100",
			"ENTRY_ID" : "liva2017extracting",
			"date" : "1501545600"
		},
		{
			"id" : 3,
			"title" : "Modeling Time in Java Programs for Automatic Error Detection",
			"abs"   : "Modern programming languages, such as Java, represent time as integer variables, called timestamps. Timestamps allow developers to tacitly model incorrect time values resulting in a program failure because any negative value or every positive value is not necessarily a valid time representation. Current approaches to automatically detect errors in programs, such as Randoop and FindBugs, cannot detect such errors because they treat timestamps as normal integer variables and test them with random values verifying if the program throws an exception. In this paper, we present an approach that considers the time semantics of the Java language to systematically detect time related errors in Java programs. With the formal time semantics, our approach determines which integer variables handle time and which statements use or alter their values. Based on this information, it translates these statements into an SMT model that is passed to an SMT solver. The solver formally verifies the correctness of the model and reports the violations of time properties in that program. For the evaluation, we have implemented our approach in a prototype tool and applied it to the source code of 20 Java open source projects. The results show that our approach is scalable and it is capable of detecting time errors precisely enough allowing its usability in real-world applications.",
			"authors" : "G. Liva, M. T. Khan, F. Spegni, L. Spalazzi, A. Bollin, M. Pinzger",
			"url"  : "./papers/Modeling_Time_in_Java_Programs_for_Automatic_Error_Detection.pdf",
			"tool" : "https://github.com/rtse-project/automatic-error-detection",
			"year" : "2018",
			"venue": "Proceedings of the 6th Conference on Formal Methods in Software Engineering (FormaliSE)",
			"img"  : "approach.png",
			"img_caption" : "Overview of our approach for detecting time property violations. Time Slice slices the program keeping only the statements that alter and use time variables. Path Generation generates multiple execution paths of the slice based on its control flow. SMT Translation translates each path into SMT constraints. Each model of SMT constraints is fed into an SMT solver to check for violations of time properties in the source code.",
			"pages": "50--59",
			"ENTRY_ID" : "liva2018modelling",
			"date" : "1535760000"
		},
		{
			"id" : 4,
			"title" : "Automatic verification of time behavior of programs",
			"abs"   : "Automatic verification of software could save companies from huge losses due to errors in their programs. Existing techniques to prevent and detect errors are mainly based on imprecise heuristics which can report false positives. Formal verification techniques are an alternative to the heuristic approaches. They are more precise and can report errors with higher rigor. However, they cannot be directly applied because current programming languages have no defined semantics that specifies how the source code is interpreted in the execution of programs. Moreover, no existing work tries to develop a semantics for the time domain. The target of this thesis is to provide a verification framework based on a defined time semantics that can help developers to automatically detect time related errors in the behavior of programs. We define a time semantics that allows us to ascribe a meaning to source code statements that alter and use time. Based on the time semantics, we develop an approach to (i) automatically assert time properties and (ii) reverse engineer timed automata, a formal model of the time behavior that is amenable for verification. We plan to evaluate our approaches with quantitative and qualitative studies. The quantitative studies will measure the performance of our approaches in open source projects and the qualitative studies will collect the developers' feedback about the applicability and usefulness of our proposed techniques.",
			"authors" : "G. Liva",
			"url"  : "./papers/expose.pdf",
			"tool" : "",
			"year" : "2018",
			"venue": "Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings (ICSE)",
			"img"  : "schedule.png",
			"img_caption" : "Schedule of the work for the PhD proposal",
			"pages": "468--471",
			"ENTRY_ID" : "liva2018automatic",
			"date" : "1535660000"
		},
		{
			"id" : 5,
			"title" : "Towards Model Checking Security of Real Time Java Software",
			"abs"   : "More and more software libraries and applications in high-performance computing and distributed systems are coded using the Java programming language. The correctness of such pieces of code w.r.t. a given set of security policies often depends on the correct handling of timing between concurrent or recurrent events.Â Model-checking has proven to be an effective tool for verifying correctness of software. In spite of the growing importance of this application area of formal methods, though, no one targets the problem of verifying the correctness of real-time software w.r.t. timed specifications. The few existing works focus on very different problems, such as schedulability analysis of Java tasks. We describe an approach combining rule-based static analysis together with symbolic execution of Java code to extract networks of timed automata from existing software and then use Uppaal to model-check it against timed specifications. We claim that this approach can be helpful in model-checking security policies of real time java software.",
			"authors" : "F. Spegni, L. Spalazzi, L. Giovanni, M. Pinzger",
			"url"  : "./papers/SHPCS_2018_paper_5.pdf",
			"tool" : "https://git-isys.aau.at/giliva/java-time-verification/tree/term_rewriting",
			"year" : "2018",
			"venue": "Proceedings of the 13th International Workshop on Security and High Performance Computing Systems (SHPCS 2018)",
			"img"  : "model.png",
			"img_caption" : "A methodology for extracting networks of timed automata from Java code.",
			"pages": "to-appear",
			"ENTRY_ID" : "spegni2018towards",
			"date" : "1536660000"
		}
	]
}
